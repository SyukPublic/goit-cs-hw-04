# Домашнє завдання до модуля “Конкурентність та паралелізм”  
## (Тема 7 та 8)


Файл **run_test_01.py** - тест для завдання 1.   
Файл **run_test_02.py** - тест для завдання 2.     
  
Файл **generate_test_data.py** - генерує набір ключових слів та файлів для пошуку (``-h for help``).  
  
Для обох варіантів реалізації (багатопотокового та багатопроцесорного підходів) реалізовано єдиний клас, що виконує пошук. Це надає можливість більш "чисто" порівняти продуктивність кожного підходу.  
  
Для комунікації воркерів з головним процесом/потоком використано чергу та спеціальний маркер завершення (sentinel).
Таким чином, головний процес не опитує воркерів, а просто обробляє дані, що приходять у правильному порядку (результати пошуку або маркер завершення).  
**IPC мінімальний:** воркер надсилає по одному запису на файл + один sentinel наприкінці.  

При малій кількості файлів та ключових слів (до декількох десятків), у яких здійснюється пошук, перевага на стороні багатопотокового підходу.  
При зростанні кількості файлів дана перевага нівелюється, а при значній кількості файлів (декілька тисяч) перевагу набуває багатопроцесорний підхід.  
Так само при зростанні кількості ключових слів, вже при значеннях більших за сотню перевагу набуває багатопроцесорний підхід.  

Отже, накладні витрати на створення та запуск процесів цілковито окупаються на великій кількості CPU-bound задач при наявності великої кількості ядер.  
